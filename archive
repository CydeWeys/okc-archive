#!/usr/bin/env perl
use 5.010;
use strict;
use warnings;
use autodie;
use WWW::Mechanize;
use Config::Tiny;
use FindBin qw($Bin);

use constant DEFAULT_ARCHIVE => "$Bin/messages";

@ARGV or die "Usage: $0 thread-url [archive-dir]\n";

my $thread      = shift;
my $archive_dir = shift || DEFAULT_ARCHIVE;

# Switch to https if not already specified.
$thread =~ s{http:}{https:};

my ($thread_id) = ($thread =~ m{threadid=(\d+)});

# Make sure archive exists

if (not -d $archive_dir) {
    say "Creating $archive_dir...";
    mkdir $archive_dir;
}

my $mech = WWW::Mechanize->new;

# Let's make sure OKC returns code similar to what I'll see in
# Firefox.  (Also let's not be quite so obviously a bot...)

$mech->agent_alias('Linux Mozilla');

# TODO: Maybe use XDG paths?
my $config = Config::Tiny->read("$Bin/auth.ini");

unless ($config->{auth}{username}) {
    say "Hey, you need a `$Bin/auth.ini` file that looks like this:\n";
    say "[auth]\n",
        "username=your_username\n",
        "password=your_password\n"
    ;
    exit 1;
}

# Login dance!

$mech->get("https://www.okcupid.com/login");

$mech->submit_form(
    form_id   => 'login_form',
    fields    => {
        username => $config->{auth}{username},
        password => $config->{auth}{password},
    },
);

# Fetch the message thread specified
$mech->get($thread);

my $content = $mech->content;

my ($remote_user) = ($content =~ m{Your conversation with (\w+)});

$remote_user or die "Oh noes! I don't know who this convo is with...\n";

open(my $fh, '>', File::Spec->catfile($archive_dir, "$remote_user.$thread_id"));

# Double-lines of output? Such ugly!

say       "=== Conversation with $remote_user ($thread_id) ===\n";
say {$fh} "=== Conversation with $remote_user ($thread_id) ===\n";

# We started off trying to use XPath, but OKC doens't exactly return
# well-formed XML. Instead, we'll use hacks...

while ($content =~ m{
    <a[^>]*href="/profile/(?<from>\w+)[^"]*"[^>]*class="photo"
    .*?
    <div\s*class="message"[^>]*>(?<content>.*?)</div>\s*</li>
}msgx) {

    my $from = $+{from};
    my $msg  = $+{content};

    # Convert HTML to plain text... mostly.

    $msg =~ s{<div class="message_body">}{\n}msg;
    $msg =~ s{<script>.*?</script>}{}msg;
    $msg =~ s{</?(?:br|div)[^>]*/?>}{\n}msg;
    $msg =~ s{</?span[^>]*>}{}msg;
    $msg =~ s{<a [^>]*>}{}msg;
    $msg =~ s{</a>}{}msg;
    $msg =~ s{^[ ]*}{}msg;

    # Print our message.

    say {$fh} "[$from]\n$msg";
    say {$fh} "-" x 70;
}
